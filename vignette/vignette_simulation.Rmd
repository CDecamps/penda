---
title: "vignette_simulation"
author: "Cl√©mentine Decamps"
date: "9 mars 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("~/projects/penda/R/simu.R")
source("~/projects/penda/R/ranking.R")
source("~/projects/penda/R/testing.R")
Rcpp::sourceCpp('~/projects/penda/R/ranking_rcpp.cpp')

```


##Data processing

Import your control datas, the bigger they are, the longer the analysis takes.
You can use the function "detect_zero_value" to eliminates genes with more than "threshold" % of expression value under "min" in control or cancer datas. For example : 

#'null_values = detect_zero_value(your_data, your_cancer_data, threshold = 0.99, min = 10)
#'your_data = your_data[!null_values,]
#'your_cancer_data = your_cancer_data[!null_values,]

The five last patients are used to makes "simu_data" and simulates the dysregulation. They are substracte of "ctrl_data" for not distort the next steps.

```{r, tidy=TRUE, tidy.opts=list(blank=FALSE, width.cutoff=55)}
ctrl_data = readRDS('~/projects/perso_DA/data_ctrl_process.rds')
LUSC_data = readRDS('~/projects/perso_DA/data_LUSC_process.rds')

simu_data = ctrl_data[, (ncol(ctrl_data)-4):ncol(ctrl_data)]
colnames(simu_data) = c("P1","P2","P3","P4","P5")

ctrl_data = ctrl_data[, -((ncol(ctrl_data)-4):ncol(ctrl_data))]
```


##Making simulations

The function "simplified_simulation" allows to simulate the dysregulation in our 5 test patients. You can choose several parameters, the first is the "fraction" of datas to dysregulate. The dysregulation is +- "modifier" if the gene expression is under the "threshold", or * / "factor" if the gene expression is above. 
You must adapt your parameters at the expected dysregulation in your real dysregulated datas.
The simulation returns the vector of initial data, the vector of datas with modifications and the index of modified data. We gather these vectors in matrices in the list "simulation".

```{r, tidy=TRUE, tidy.opts=list(blank=FALSE, width.cutoff=55)}

simup1 = simplified_simulation(simu_data[,1], fraction = 0.3)
simup2 = simplified_simulation(simu_data[,2], fraction = 0.3)
simup3 = simplified_simulation(simu_data[,3], fraction = 0.3)
simup4 = simplified_simulation(simu_data[,4], fraction = 0.3)
simup5 = simplified_simulation(simu_data[,5], fraction = 0.3)

simulation = list()

simulation$initial_data = matrix(c(simup1$initial_data, simup2$initial_data, simup3$initial_data, simup4$initial_data, simup5$initial_data), ncol=5, dimnames = list(rownames(simu_data)))
simulation$simulated_data = matrix(c(simup1$simulated_data, simup2$simulated_data, simup3$simulated_data, simup4$simulated_data, simup5$simulated_data), ncol=5, dimnames = list(rownames(simu_data)))
simulation$changes_idx = matrix(c(simup1$changes_idx, simup2$changes_idx, simup3$changes_idx, simup4$changes_idx, simup5$changes_idx), ncol=5)
```


##Ranking in control

The function "find_D_U_ctrl" search for each genes what are genes more and less expressed in most of the cases. You can choose the limit distribution of genes studied with parameters "quant" and "factor." For one gene g, we consider only genes between (the quantile quant of g distribution / factor) and (the quantile (1-quant) of g distribution * factor).
The bigger your limits are, the more up and down-expressed genes you will have for each gene.
The last parameter of "find_D_U_ctrl" is the "threshold", the proportion of patients that must be in the conditions (differential expression and between the limits). A higher threshold increase the robustness of the lists, but decrease the number of genes differentially expressed.
"find_D_U_ctrl_rcpp" is faster but need rcpp package.

The new function "find_D_U_ctrl_size" replaces the limit based on quantile with a limit on number of genes in each list. The parameter "s_max" is the maximum number of D and U genes for each gene. A little numbler of D and U genes, center on the gene expression, seems more signifiant.

These functions return two matrix. For each gene in columns, the row gene is "TRUE" if is **D**own-expresed or **U**p-expressed.

```{r, tidy=TRUE, tidy.opts=list(blank=FALSE, width.cutoff=55)}

# D_U_ctrl = find_D_U_ctrl(ctrl_data, quantile = 0.001, factor = 4, threshold = 0.99)
# saveRDS(D_U_ctrl, "D_U_93p.rds")
D_U_ctrl = readRDS("D_U_93p.rds")

#D_U_ctrl = find_D_U_ctrl_rcpp(ctrl_data, quantile = 0.001, factor = 4, threshold = 0.99)
#D_U_ctrl = find_D_U_ctrl_size(ctrl_data, threshold = 0.99, s_max = 100)
```


##Test the dysregulation

The next step is to compare your control dataset and your dysregulate datas to detect genes with an up or down regulation. For that, it's the function "patient_test" which makes the dysregulation test for each genes of one patient.

The firt step is called "step0". We look at the normal distribution of each gene, if the patient gene is at the extremities of this distribution, it's suspect and we remove it of the D_U_ctrl. It's the parameter "quant_0" which allows to determine the accepted distribution, between the quantile quant_0(gene distribution) and the quantile 1-quant_0(gene distribution). A higher quantile is supposed to improve the FDR and to make the test faster, but it also decrease the TPR.

After that, "regulation_test" is made the number of "iterations" requested until the stabilisation. This test checks for each gene if down-genes "D" or up-genes "U" have changed. "Du" are D genes become up, and "Ud" are U genes become down. The test need a threshold, if (Ud/U) and (Du/D) are under this threshold, we consider that this gene is not dysregulated. If you choose a threshold too high, you will have lots of false-positive, but if you choose a threshold too low you increase your number of false-negative. A small threshold can also increase the number of iterations before the stabilisation, and so the time of the test.

To help your choose of the threshold for the test, and the quantile for the step0, you can use the function "multiple_test".
This function allows to vary quantile or threshold values, with a vector of multiple value, an unique value for the other parameter, and TRUE or FALSE for the "threshold_change".
```{r, tidy=TRUE, tidy.opts=list(blank=FALSE, width.cutoff=55)}

threshold_values = c(0.003, 0.1, 0.2, 0.3, 0.5)
quantile_values = c(0, 0.005, 0.01, 0.03, 0.05, 0.1)

#test_threshold = multiple_tests(ctrl_data, D_U_ctrl, iterations = 10, simulation, threshold_values, 0.03)
# saveRDS(test_threshold, "test_threshold.rds")
test_threshold = readRDS("test_threshold.rds")

#test_quantile = multiple_tests(ctrl_data, D_U_ctrl, iterations = 10, simulation, quantile_values, 0.2, threshold_change = FALSE)
# saveRDS(test_quantile, "test_quantile.rds")
test_quantile = readRDS("test_quantile.rds")


#Data frame FDR and TPR for the two simulations
df_thres = data.frame(patient = test_threshold[,1], threshold = test_threshold[,2], FDR = as.numeric(test_threshold[,3]), TPR = as.numeric(test_threshold[,4])) 

df_quant = data.frame(patient = test_quantile[,1], quantile = test_quantile[,2], FDR = as.numeric(test_quantile[,3]), TPR = as.numeric(test_quantile[,4])) 

#Graphic representation
library(ggplot2)
graph_thres = ggplot(df_thres, aes(x = TPR, y = FDR, color = threshold, group = patient, shape = patient)) + geom_point() + geom_line()
graph_quant = ggplot(df_quant, aes(x = TPR, y = FDR, color = quantile, group = patient, shape = patient)) + geom_point() + geom_line()

#Threshold : 
graph_thres

#Quantile : 
graph_quant

```

